require 'spec_helper'
require 'msf/core'
require 'msf/core/exploit/browser/server'

describe Msf::Exploit::Remote::BrowserExploitServer do

  subject(:server) do
    mod = Msf::Exploit.allocate
    mod.extend described_class
    mod.send(:initialize, {})
    mod
  end

  let(:service_double) do
    service = double("service")
    service.stub(:server_name=)
    service.stub(:add_resource)

    service
  end

  let(:profile_name) do
    "random"
  end

  let(:expected_os_name) do
    "linux"
  end

  before do
    Rex::ServiceManager.stub(:start => service_double)
  end

  before(:each) do
    server.start_service
  end

  describe ".get_module_resource" do
    it "should give me a URI to access the exploit page" do
      ivar_exploit_page = server.instance_variable_get(:@exploit_receiver_page)
      module_resource = server.get_module_resource
      module_resource.should match(ivar_exploit_page)
    end
  end

  describe ".requirements" do
    let (:actual_requirements) do
      server.instance_variable_get(:@requirements)
    end

    it "should begin with an empty hash by default" do
      actual_requirements.should eq({})
    end

    it "should have these requirements: script or headers for source, and windows for OS" do
      opts = {
        :source  => /script|headers/i,
        :os_name => /win/i
      }

      server.requirements(opts)
      actual_requirements.should eq(opts)
    end
  end

  describe ".get_bad_requirements" do
    it "should not contain any bad requirements" do
      fake_profile = {
        "rMWwSAwBHLoESpHbEGbsv" => {
          :source    => "script",
          :os_name   => "Microsoft Windows",
          :os_flavor => "XP",
          :ua_name   => "MSIE",
          :ua_ver    => "8.0",
          :arch      => "x86",
          :office    => "null",
          :proxy     => false,
          :language  => "en-us",
          :tried     => true
        }}

        server.get_bad_requirements(fake_profile).should eq([])
    end

    it "should have identify :os_name as a requirement not met" do
      fake_profile = {
        "rMWwSAwBHLoESpHbEGbsv" => {
          :os_name   => expected_os_name
        }}

      server.requirements({:os_name=>/win/i})
      baddies = server.get_bad_requirements(fake_profile)
      baddies.should eq([:os_name])
    end
  end

  describe ".init_profile" do
    it "should initialize an empety profile for tag 'random'" do
      server.init_profile(profile_name)
      ivar_target_profile = server.instance_variable_get(:@target_profiles).first
      ivar_target_profile[profile_name].should eq({})
    end
  end

  describe ".get_profile" do
    it "should only contain one hash for each profile" do
      server.init_profile(profile_name)
      p = server.get_profile(profile_name)
      p.length.should eq(1)
    end

    it "should return nil when a profile isn't found" do
      server.init_profile(profile_name)
      p = server.get_profile("non_existent_profile")
      p.should be_nil
    end

    it "should return a profile if found" do
      server.init_profile(profile_name)
      p = server.get_profile(profile_name)
      p[profile_name].should_not be_nil
    end
  end

  describe ".update_profile" do
    it "should update my target profile's :os_name information" do
      server.init_profile(profile_name)
      profile = server.get_profile(profile_name)
      server.update_profile(profile, :os_name, expected_os_name)
      profile = server.get_profile(profile_name)
      os_name = profile[profile_name][:os_name]
      os_name.should eq(expected_os_name)
    end
  end

  describe ".get_detection_html" do
    it "should return the detection code that the client will get" do
      html = server.get_detection_html
      html.should_not eq('')
    end
  end

end