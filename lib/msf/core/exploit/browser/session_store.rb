# -*- coding: binary -*-

require 'cgi'

module Msf

###
#
# The SessionStore class handles persisting information on a browser client
# across connections. For now, the SessionStore keeps all its data in memory and
# will also write to disk on any update.
#
###
module Exploit
module Remote
module Browser
module SessionStore

  TAG_LEN = 32 # alpha-numeric characters in tag

  # @attr [SessionStoreInstance] session_store holds all memory for a session
  attr_reader :session_store

  # Stub initialize to set up the session_store
  def initialize(args={})
    super(args)
    @session_store = SessionStoreInstance.new
  end

  # Mix the extra Client methods into the Client instance
  def filter_request_uri(cli, req)
    cli.include(SessionStoreClientMethods)
    cli.unknown = false
    cli.session ||= @session_store.create_session(client_tag(req))
    false
  end
  
  # Found by checking cookie, GET param, or ETAG header
  # Otherwise a unique tag is generated, which can be "hooked up" later
  # if a pre-existing tag is found in another client-side persisitence method
  # @param [Request] req
  # @return [String] unique tag for this client
  def client_tag(req)
    # first check for a GET param
    query = req.qstring[@session.id]
    if query.present? and query =~ /^[^\s]+$/ and query.length == TAG_LEN
      return query.to_s
    end

    # now check the cookie
    cookie_hash = CGI::Cookie.parse(request.headers['Cookie'].to_s)
    cookie = cookie_hash[@session_store.id]
    if cookie =~ /^[^\s]+$/ and cookie.length == TAG_LEN
      return cookie.to_s
    end

    # now check the etag
    etag = request.headers['ETag']
    id_len = @session_store.id.length
    if etag.present? and etag.start_with?(@session_store.id) and etag.length == id_len + TAG_LEN
      return etag.to_s[id_len...-1] # lchomp the identifier
    end

    # could not recognize the client from their request headers
    cli.unknown = true

    # default to a new id
    # note that the client js might discover the actual tag later (e.g. in flash
    # storage, and will switch to that instead
    random_tag
  end

  # @return [String] randomly generated string with TAG_LEN characters
  def random_tag
    Rex::Text::rand_text_alphanumeric(TAG_LEN)
  end

  # For mixing into the browser client connections
  module SessionStoreClientMethods

    # @attr [Msf::Exploit::Remote::Browser::Session] session for this client
    attr_accessor :session

    # @attr [Boolean] client was fingerprinted with cookie/etag as a pre-existing session
    attr_accessor :unknown

    protected

    # Call this method to inject HTML into your response and
    # alter response headers so that the subsequent requests/connections
    # will be identifiable.
    #
    # Many of these ideas were taken from Samy's evercookie:
    # https://github.com/samyk/evercookie
    #
    # The fingerprint HTML that is returned does the following:
    # 1. Stores the tag in the browser's cookie
    # 2. Stores the tag in a Flash cookie
    # 3. Stores the tag in the window.name
    # 4. Stores the tag in HTML5's SessionStorage, LocalStorage, GlobalStorage,
    #    and DatabaseStorage
    # 5. Stores the tag in the user's cache
    # 6. [TODO] Stores the tag in Silverlight Isolated Cookies
    # 7. Stores an e-tag header that is detectable later
    # 8. Stores the tag in IE's userData
    #
    # All storage mechanism must be "replace-or-append", so that
    # multiple modules running separate SessionStores will not be confused.
    #
    # Not all of these will be detectable on the next request,
    # but fingerprinting will expose a Tag global that can be sent
    # up as a parameter when reporting data.
    #
    # @return [String] HTML to add to the response
    def inject_cookie(req)
      headers = ['']
      js = %Q|
        (function() {
          var tag = '#{session.tag}';
          var sstag = '#{session.session_store.tag}';
          var m = sstag + '=' + tag; 
          document.cookie = m;
          // set flash cookie
          var hasFlash = false;
          try { hasFlash = !!(new ActiveXObject('ShockwaveFlash.ShockwaveFlash')); } catch(e){}
          hasFlash = hasFlash \|\| (navigator && navigator.mimeTypes &&
              navigator.mimeTypes["application/x-shockwave-flash"] &&
              navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin);
          if (hasFlash) {
            var embed = document.createObject('embed');
            embed.style.visibility = 'hidden';
            embed.setAttribute('type', 'application/x-shockwave-flash');
            document.body.appendChild(embed);
            embed.setAttribute('source', '<<put resource here >>');
            window.___onFlashReady = function() {
              setTimeout(function(){
                if (window.___writeFlash) window.___writeFlash(sstag, tag);
              }, 1);
            };
          }
          // set window.name
          window.name = window.name.replace(/#{session.session_store.tag}=.*?(&\|$)/, '&');
          window.name += m;
          // set html5 storages
          var storages = ['localStorage', 'sessionStorage', 'globalStorage']
          var idx, storage;
          for (idx = 0; idx < storages.length; idx++) {
            storage = storages[idx];
            if (window[storage]) {
              window[storage][sstag] = tag;
            }
          }
          // set cached image
          var img = new Image();
          img.src = 'get_resource_should_go_here.png?tag='+tag;
          img.setAttribute('style', 'visibility:hidden');
          document.body.appendChild(img);
          // set ie userdata
          var div = document.createElement("div");
          div.innerHTML = "<!--[if lte IE 8]><i></i><![endif]-->";
          var isIe8orLower = (div.getElementsByTagName("i").length == 1)
          if (isIe8orLower) {
            var textarea = document.createElement('textarea');
            textarea.setAttribute('style', "visibility:hidden; behavior:url('#default#userData')");
            textarea.setAttribute('id', sstag);
            textarea.setAttribute('sPersistAttr', tag);
            document.body.appendChild(textarea);
            textarea.save('oDataStore');
          }
        })();
      |
    end

    # Checks all the fingerprint methods available, setting window.TAG global
    # if it finds a Tag of the right format anywhere.
    #
    # @return [String] javascript code that sets window.TAG if it finds a stored/cached tag
    def check_cookie(cli, req)
      %Q|
        (function() {
          var sstag = '#{session.session_store.id}';
          var regex = /#{session.session_store.id}=([0-9a-f])+$/i;

          // check cookie
          var m;
          if (m = document.cookie.match(regex)) {
            window.TAG = m[1];
          }

          // check flash lso cookie
          var hasFlash = false;
          try { hasFlash = !!(new ActiveXObject('ShockwaveFlash.ShockwaveFlash')); } catch(e){}
          hasFlash = hasFlash \|\| (navigator && navigator.mimeTypes &&
              navigator.mimeTypes["application/x-shockwave-flash"] &&
              navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin);
          if (!window.TAG && hasFlash) {
            var embed = document.createObject('embed');
            embed.setAttribute('style', 'visibility:hidden');
            embed.setAttribute('type', 'application/x-shockwave-flash');
            // flash onload callback
            window.___onFlashReady = function() {
              setTimeout(function(){
                if (window.___readFlash) window.___readFlash(sstag);
              }, 1);
            };
            document.body.appendChild(embed);
            embed.setAttribute('source', '<<put resource here >>');
          }

          // check window.name
          if (!window.TAG && (m = window.name.match(regex))) {
            window.TAG = m[1];
          }

          // check HTML5 targets
          if (!window.TAG && 'Storage' in window) {
            var storages = ['localStorage', 'sessionStorage', 'globalStorage'];
            var idx, storage;
            for (idx = 0; idx < storages.length; idx++) {
              storage = storages[idx];
              if (!window.TAG && window[storage] && (m = window[storage][sstag])) {
                window.TAG = m;
              }
            }
          }

          // try load of cached image
          if (!window.TAG && 'HTMLCanvasElement' in window) {
            var img = new Image();
            img.src = 'get_resource_should_go_here';
            img.onload = function() {
              // todo: load into <canvas>, convert pixels to TAG
              var canvas = document.createElement('canvas');
              canvas.width = '200px';
              canvas.height = '100px';
              canvas.style.visibility = 'hidden';
              document.body.appendChild(canvas);
              var ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              // decode the image pixels
              var imgd = ctx.getImageData(0, 0, 200, 1);
              var i, pngd = '';
              for (i = 0, i < imgd.data.length; i += 4) {
                if (pix[i])   pngd += String.fromCharCode(pix[i]);
                if (pix[i+1]) pngd += String.fromCharCode(pix[i+1]);
                if (pix[i+2]) pngd += String.fromCharCode(pix[i+2]);
              }
              if (pngd.match(regex)) {
                window.TAG = pngd;
              }
            };
            img.setAttribute('style', 'visibility:hidden');
            document.body.appendChild(img);
          }

          // check ie userData
          var div = document.createElement("div");
          div.innerHTML = "<!--[if lte IE 8]><i></i><![endif]-->";
          var isIe8orLower = (div.getElementsByTagName("i").length == 1)
          if (isIe8orLower) {
            var textarea = document.createElement('textarea');
            textarea.setAttribute('style', "visibility:hidden; behavior:url('#default#userData')");
            document.body.appendChild(textarea);
            textarea.load('oDataStore');
            if (!window.TAG) {
              window.TAG = textarea.getAttribute('sPersistAttr');
            }
          }
        })();
      |
    end
  end

  # Holds a collection of Sessions
  class SessionStoreInstance
    # @attr [String] identifier for this session-store. defaults to 'msf'
    attr_accessor :id

    # @param [Hash] opts the options hash
    # @option opts [String] :id (msf) the identifier. changing this will make sessions attained
    # from any other SessionStoreInstance inaccessible.
    # @option opts [String] :max_space (128) megabytes of disk space to allocate to hold all sessions.
    def initialize(opts={})
      @id = opts.fetch(:id, 'msf')
      @max_disk_space = opts.fetch(:max_space, 128)
      @mutex = Mutex.new
      @sessions = {} # a map of Tag (any identifier) -> Session
    end

    # Yields the block in a thread-safe way
    def sync(&block)
      @mutex.synchronize(&block)
    end

    # @param [String] tag
    # @return [Session] a Session with #session_store = self
    def create_session(tag)
      Msf::Exploit::Remote::Browser::Session.new(self, tag)
    end
  end

  # Used to store data about a specific browser client.
  class Session
    # @attr [Msf::Exploit::Remote::Browser::SessionStore] the SessionStore that this Session belongs to
    attr_reader :session_store
    # @attr [String] unique tag for this session
    attr_reader :tag

    # @param [SessionStore] session_store the Store that allocated and retains this Session
    # @param [String] the session_id
    def initialize(session_store, tag)
      @tag = tag
      @data = {}
    end

    # @param [String] key the key to set
    # @param [#to_hash] value the value to store
    # @param [Hash] opts the options hash
    # @option opts [String] :save saves the Session to disk after this request. defaults to true.
    def set(key, value, opts={})
      set({ key => value }, opts)
    end
    alias_method :[]=, :set

    # @param [Hash<#to_s,#to_json>] data to merge into the hash
    # @param [Hash] opts the options hash
    def set(data, opts={})
      # run all of data's keys through #to_s
      @session_store.sync { @data.merge!(data) }
    end

    # @param [#to_s] key the key to lookup
    # @return [#to_json] value
    def get(key)
      @session_store.sync { @data[key.to_s] }
    end
    alias_method :[], :get

    # Persists the @data to a file (for now).
    def save; end
  end

end # SessionStore
end # Browser
end # Remote
end # Exploit

end # Msf
